Пропущённое из книги:
- new
- server
- generate controller


Что надо тактически:

- парсить в mlt типы данных -- список, хеш, тело

Плохо то, что могут понадобиться вложенные хеши, списки и прочее непростое,
тогда непонятно, как мапить их на камлофункции.  Как вариант, если директива
простая, без вложенного, то мапить на dir_slh (string hash list), а сложнее --
на dir_gen : expr -> ..., где
expr = [ String of string | Hash of list (string * expr) | List of list expr ]



Что надо принципиально:


Для моделей должны быть отдельные модули.  Чтобы валидация и что около неё
не перекрывалось промеж моделями, хотя бы.


Для config/database:

Уметь сгенерить доку: в шаблон вставить пустую строку вместо database.ml,
натравить ocamldoc.

Уметь указать реальный database.ml вида

    Pg.conn_info ~host:.. ~user:.. ~pass:..

Тут же продумать: а ведь conn_info имеют разный тип для разных бд.
Получается, надо хранить [ Ci_pg of Dbi_pg.conn_info | Sqlite of Dbi_s of .. ]
для хранения инфы о соединении, далее вызывать нужный new Dbi_xx.connection,
а дальше -- как бы сделать так, чтобы код не требовал указаний типов?
Видимо решение тут -- подгонять dbi под общий интерфейс и использовать тут
только его.


Для миграций:

возможность указать файлы, прилепить им в начало
module <Filename> = struct let __filename = "filename.ml" open Xxx open Yyy
  <filename.ml contents>
end
, скомпилировать каждый, слинковать с pre.cmo + файлы по порядку + post.cmo,
запустить с нужными аргументами.


Для хранения и изменения схемы бд:

По окончании соответствующего migrate/rollback -- срать полученной схемой
в dbscheme.ml.
Как получать схему -- хранить соответствия "таблица -> мета * столбцы"
и изменять её функциями из миграций (add_column, change...).


Для использования бд -- модели.


Модель -- объект с нужными полями и методами, генерится по схеме.

Как связи обрабатывать?  Как вариант -- разделить мета (из чего генерится
тип объекта) и код модели?

Но как тогда валидировать?  В мета должна быть ссылка на функцию, которая
валидирует.

% model  -- генерит по схеме таблицы __filename ^"s" класс
^^^^^^^ а вообще, это надо для всех моделей, поэтому в общем шаблоне будет.

let myvalfunc s = s <> ""
% validate_fun "fieldname" myvalfunc
  -- прописывает нужное в метод model#validate || failwith "fieldname"

или типа-инлайн:
% begin_validate
  check (self#x > 123)
% end_validate

  ->
    print_string "let () = add_validation ("
      print_string "#line fff, 123"
      print_string "check (self#x > 123)"
    print_string ");;"

% validate_presence "fieldname"
 == "check (self#fieldname !~ /\s*/) || failwith "fieldname""

---

Связи между моделями -- как?  Очевидно, список надо получать лениво
и/или мемоизировать (то есть, method subs = Lazy.force value_subs).
А как писать туда?  Видимо, model#set_subs newsubs?



Как проверять routes.ml на предмет "есть все роуты" (или отрубать
несуществующие):

Компилируем все контролеры, завёрнутые в функтор от Unit : sig end,
и пишем код "module Test(U : Unit) = struct
ignore (Controller.method : method_type) .. end".  Применять Unit
не обязательно.
А с контролером можно и хелпер скомпилировать, сделав ему open.


Директиве нужно знать свой location.  Поэтому:
- перед pre- добавляем "let _dir_loc = ref ("_none_", 0)"
- каждую директиву вместо Dir (dir2 arg1 arg2) оформляем как
  Dir (fun ctx -> _dir_loc <- ("fname", lineno); dir2 arg1 arg2 ctx),
- документируем, что _dir_loc доступен в обработчике директивы либо
  после его завершения



Для более годных сообщений об ошибках можно при стейджинге делать:
- линковать все pre-, смотреть на статус
- линковать все pre-, let mlt = [], post-, смотреть на статус
- пробовать парсить ошибки компилятора, ещё переименовать директивы в
  dir_имя_StrLstHshBdy, и в случаях, когда не найдено, расшифровывать имя.
  Или же более надёжно: если оказывается так, что компилируется с ошибкой,
  брать все директивы, пихать их в let _ = dir_... let _ = dir_...,
  писать это после всех pre-, можно даже "двоичным поиском" делить их
  (сейчас один набор проверили, потом другой; вспомнить задачи про
  нахождение отравленного сосуда), успешную компиляцию выкидывать,
  неуспешную уточнять, пока не будут найдены отсутствующие шняги.
  Хотя достаточно только одну найти -- первую.  То есть, всё, что встретилось
  по порядку в Dir, делим пополам, идём: 0..7=fail 0..3=fail 0..1=ok ->
  2..3=fail -> проверяем 2, затем 3.
- если посмотреть на пункт "линковать все pre-", например, то там тоже может
  быть нужно "половинное деление", чтобы знать, где лажа.  Или даже лажа
  может быть в тех вещах, которые мы добавляем вне pre-, перед ними.
  Вывод такой: все файлы надо хранить в памяти (можно сразу с #line),
  сделать кеш с явной очисткой нужных сущностей после выхода из Staging.stage,
  но некоторые сущности прилепить намертво, типа src/codegen.ml или будущего
  tpl/internal/dir_loc.ml.  Там же: подумать, что ещё можно вынести в такое
  кешируемое.  mldir, call_generation?  А может и "let _ = dir_..." тоже
  вынести в такие сущности?  Нехай себе компиляется, если всё успешно, как
  есть, а при неудаче -- штатная бисекция по ним тоже.
